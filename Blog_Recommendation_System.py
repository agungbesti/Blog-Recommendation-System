# -*- coding: utf-8 -*-
"""Blog Recommendation System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nIHT-w5c7143SVewCiD27kG4QEQa4IiF

---
# Import Module
---
"""

# Commented out IPython magic to ensure Python compatibility.
# import required packages
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

import pandas as pd
import numpy as np
import nltk
import re
from nltk import corpus
from nltk.stem import WordNetLemmatizer
from nltk.stem import PorterStemmer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity, euclidean_distances
from sklearn.model_selection import train_test_split
from nltk import wsd
from nltk.corpus import wordnet as wn
nltk.download('stopwords')
nltk.download('wordnet')

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from keras.callbacks import  EarlyStopping

"""---
# Data Understanding
Dataset ini berisi informasi blog sebanyak 10467, informasi author blog sebanyak 6868 dan informasi yang memberikan rating blog sebanyak 200140.

untuk file csv terdiri dari 3 file, yaitu:

1. Medium Blog Data
2. Author Data
3. Blog ratings
---
"""

blog_df = pd.read_csv('/content/Medium Blog Data.csv')
author_df = pd.read_csv('/content/Author Data.csv')
ratings_df = pd.read_csv('/content/Blog Ratings.csv')

"""---
# Univariate Exploratory Data Analysis
variabel - variabel pada dataset ini adalah:

**blog_df**

- blog_id : id unik nama blog
- author_id : id unik penulis blog
- blog_title : judul blog
- blog_content : ringkasan isi blog
- blog_link : link blog
- blog_img : gambar blog
- blog_topic : topik blog yang ditulis.

**author_df**

- author_id : id unik penulis blog
- author_name : nama penulis blog

**ratings_df**

- blog_id : id unik nama blog
- user_id : id pengguna
- ratings : rating yang diberikan oleh pengguna

---
"""

blog_df

author_df

ratings_df

"""---
## Blog Variabel

Deskripsi blog variabel

---
"""

blog_df.info()

print("="*10,'[Topik Blog yang di Posting]',"="*10)
blog_df['topic'].value_counts()

"""---
## Author Variabel

Deskripsi author variabel

---
"""

author_df.info()

print('Banyak Penulis Artikel: ', len(author_df.author_id.unique()))

"""---
## Rating Variabel

Deskripsi rating variabel

---
"""

ratings_df.info()

ratings_df.describe()

"""Rata-rata rating blog yang diberikan user berkisar antara 0.5 sampai 5"""

print('Jumlah userID: ', len(ratings_df.userId.unique()))
print('Jumlah blogID: ', len(ratings_df.blog_id.unique()))
print('Jumlah data rating: ', len(ratings_df))

def showTopicList(df):
    # Split the topic in each row and create a list of individual topic
    topic_lists = df['topic'].str.split(', ')

    # Flatten the list of lists
    flattened_topics = [topic for topics in topic_lists for topic in topics]

    # Get the unique topic
    unique_topics = pd.Series(flattened_topics).unique()

    # Display the unique topic
    print(unique_topics)

    print("\nTotal\n")
    print(df['topic'].str.split(', ').explode().value_counts().to_markdown())

# List topic pada dataset blog
showTopicList(blog_df)

def showTopicPlot(df):
  # Count the occurrences of each topic
  topic_counts = df['topic'].str.split(', ').explode().value_counts()

  # Create the bar plot
  plt.figure(figsize=(15, 6))
  plt.bar(topic_counts.index, topic_counts.values, width=0.6)

  # Set the labels and title
  plt.xlabel('Topic')
  plt.ylabel('Count')
  plt.title('Topic Distribution')

  # Rotate the x-axis labels for better readability
  plt.xticks(rotation=90)

  # Display the plot
  plt.show()

# Visualisasi untuk kolom topic pada dataset blog
showTopicPlot(blog_df)

"""Pada visualisasi diatas, topik blog yang banyak ditulis adalah ai (artificial inteligence)"""

# Visualisasi untuk kolom rating pada dataset ratings
plt.figure(figsize=(8,4))
sns.countplot(x=ratings_df["ratings"])

"""Rating terbanyak yang diberikan adalah 5

---
# Data Preprocessing

Menghapus kolom yang tidak diperlukan

---
"""

blog_df.drop(['author_id','blog_link','blog_img','scrape_time'],axis='columns',inplace=True)

blog_df

# Menghapus blog yang duplikat
blog_df.drop_duplicates(['blog_title','blog_content'],inplace=True)

blog_df

"""---
# Preprocessing Text Data

Melakukan praproses pada text data untuk menghapus stopwords dari konten blog dan juga menerapkan lemmatization untuk mengembalikan semua kata ke bentuk kata dasar.

---
"""

lst_stopwords=corpus.stopwords.words('english')
def pre_process_text(text, flg_stemm=False, flg_lemm=True, lst_stopwords=None):
    text=str(text).lower()
    text=text.strip()
    text = re.sub(r'[^\w\s]', '', text)
    lst_text = text.split()
    if lst_stopwords is not None:
        lst_text=[word for word in lst_text if word not in lst_stopwords]
    if flg_lemm:
        lemmatizer = WordNetLemmatizer()
        lst_text = [lemmatizer.lemmatize(word) for word in lst_text]
    if flg_stemm:
        stemmer = PorterStemmer()
        lst_text = [stemmer.stem(word) for word in lst_text]
    text=" ".join(lst_text)
    return text

blog_df['clean_blog_content'] = blog_df['blog_content'].apply(lambda x: pre_process_text(x,flg_stemm=False,flg_lemm=True,lst_stopwords=lst_stopwords))

blog_df

"""---

# Menggunakan TFIDF Vectorizer to vectorize pada blog topic

TF-IDF, kependekan dari Term Frequency-Inverse Document Frequency, adalah teknik yang banyak digunakan dalam pemrosesan bahasa alami dan pengambilan informasi untuk mengukur pentingnya suatu istilah dalam dokumen dalam kumpulan dokumen. TF-IDF menggabungkan dua faktor: Term Frequency (TF) dan Inverse Document Frequency (IDF).

- **Term Frequency (TF)**: TF mengukur frekuensi istilah dalam dokumen. Ini menghitung berapa kali suatu istilah muncul dalam dokumen dan mewakilinya sebagai hitungan mentah atau nilai yang dinormalisasi. Alasan di balik TF adalah bahwa istilah yang lebih sering muncul dalam dokumen cenderung lebih penting atau relevan dengan dokumen tersebut.

- **Inverse Document Frequency (IDF)**: IDF mengukur signifikansi suatu istilah di seluruh kumpulan dokumen. Ini menghitung logaritma fraksi terbalik dari jumlah dokumen yang mengandung istilah tersebut. Ide di balik IDF adalah bahwa istilah yang muncul di sejumlah kecil dokumen lebih informatif dan berharga daripada istilah yang muncul di sejumlah besar dokumen..

Perhitungan TF-IDF dilakukan dengan mengalikan nilai TF dan IDF secara bersamaan. Skor yang dihasilkan merepresentasikan pentingnya suatu istilah dalam dokumen dalam konteks keseluruhan kumpulan dokumen. Skor yang lebih tinggi menunjukkan bahwa suatu istilah lebih relevan atau berbeda dengan dokumen tertentu.

Rumus perhitungan TF-IDF untuk term (t) dalam dokumen (d) dalam kumpulan dokumen adalah sebagai berikut:
[Gambar](https://ptime.s3.ap-northeast-1.amazonaws.com/media/natural_language_processing/text_feature_Engineering/tf-idf-formula.PNG)

"""

tfidf_vecotorizer = TfidfVectorizer()
tfidf_matrix = tfidf_vecotorizer.fit_transform(blog_df['topic'])
print(tfidf_matrix.shape)

"""Oleh karena itu, ada 28 kata atau vektor unik yang digunakan untuk mendeskripsikan total 10467 blog yang kami miliki dalam kumpulan data"""

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan topic blog
# Baris diisi dengan judul blog

tfid_example = pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfidf_vecotorizer.get_feature_names_out(),
    index=blog_df.blog_title
).sample(22, axis=1).sample(10, axis=0)

tfid_example

"""---
# Content Based Filtering berdasarkan topik blog

Kesamaan kosinus adalah ukuran yang digunakan untuk menentukan kesamaan antara dua vektor dalam ruang multidimensi. Ini menghitung cosinus sudut antara vektor, yang menunjukkan seberapa dekat hubungan vektor dalam hal orientasi dan arahnya.

Berikut adalah rumus untuk menghitung cosinus similarity,

[link text](https://clay-atlas.com/wp-content/uploads/2020/03/cosine-similarity.png)

Ini akan mengembalikan seberapa mirip dua vektor berdasarkan jarak di antara keduanya. Nilai ini berkisar dari 0 hingga 1 . Di mana 0 mewakili konten yang paling tidak mirip dan 1 konten yang paling mirip. Ini adalah metode yang sangat banyak digunakan dan efisien untuk membangun sistem rekomendasi berbasis konten. Itulah satu-satunya alasan kami menggunakannya untuk membangun sistem rekomendasi blog kami.

---
"""

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul blog
cosine_sim_df = pd.DataFrame(cosine_sim, index=blog_df.blog_title, columns=blog_df.blog_title)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""---
# Euclidean Distance

Euclidean distance mengidentifikasi seberapa jauh dua vektor terpisah satu sama lain. Artinya dia melihat jarak kedekatan antara dua teks.

---

"""

# Menghitung euclidean distance pada matrix tf-idf
euclidean_dist = euclidean_distances(tfidf_matrix)
# Membuat dataframe dari variabel euclidean_dist dengan baris dan kolom berupa judul blog
euclidean_dist_df = pd.DataFrame(euclidean_dist, index=blog_df.blog_title, columns=blog_df.blog_title)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

def blog_recommendations(blog_title, similarity_data=cosine_sim_df, similar_type='cosine',
                         items=blog_df[['blog_title','topic','clean_blog_content']], k=10):


    """
    Rekomendasi Blog berdasarkan kemiripan dataframe

    Parameter:
    ---
    title : tipe data string (str)
                Title movie (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan Blog sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """

    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)

    # Mengambil data dengan similarity terbesar (cosine) dan terkecil (euclidean) dari index yang ada
    if (similar_type == 'cosine'):
        index = similarity_data.loc[:,blog_title].to_numpy().argpartition(
        range(-1, -k, -1))
        # Mengambil data dengan similarity terbesar dari index yang ada
        closest = similarity_data.columns[index[-1:-(k+2):-1]]
        score = similarity_data.iloc[index[-1:-(k+2):-1],
                                     similarity_data.columns.get_loc(title)
                                    ].reset_index(drop=True)
    else:
        index = similarity_data.loc[:,blog_title].to_numpy().argpartition(
        range(k+1))
        # Mengambil data dengan similarity terbesar dari index yang ada
        closest = similarity_data.columns[index[:(k+2)]]
        score = similarity_data.iloc[index[:(k+2)],
                                     similarity_data.columns.get_loc(title)
                                    ].reset_index(drop=True)


    # Drop blog_title agar nama blog yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(blog_title, errors='ignore')
    result = pd.DataFrame(closest).merge(items).head(k)
    result['score'] = score

    return result

title = 'Relation between cloud computing and artificial intelligence'

blog_df[blog_df.blog_title.eq(title)]

blog_name = input('Apa blog yang kamu suka ?')
df2 = cosine_sim_df.filter(regex=blog_name)
column_headers = list(df2.columns.values)
for i in column_headers :
  print(i)
choosen_blog = input("Tuliskan judul blog yang kamu suka :")
print ('Inilah beberapa rekomendasi blog yang kamu suka:')
# default similarity data consine
blog_recommendations(choosen_blog, similarity_data=cosine_sim_df, similar_type='cosine')

title = 'Relation between cloud computing and artificial intelligence'

blog_df[blog_df.blog_title.eq(title)]

blog_name = input('Apa blog yang kamu suka ?')
df2 = cosine_sim_df.filter(regex=blog_name)
column_headers = list(df2.columns.values)
for i in column_headers :
  print(i)
choosen_blog = input("Tuliskan judul blog yang kamu suka :")
print ('Inilah beberapa rekomendasi blog yang kamu suka:')
# default similarity data consine
blog_recommendations(choosen_blog, similarity_data=euclidean_dist_df, similar_type='euclidean')

"""Model berhasil memberikan rekomendasi 10 judul blog dengan topic yang sama seperti yang disukai, yaitu cloud-services.

---
#Collaborative Filtering

---
"""

blog_all = pd.merge(blog_df, ratings_df, on='blog_id', suffixes=['', '_user'])
blog_all

"""Selanjutnya akan dilakukan konversi data dari data series menjadi list dan akan dilakukan encode pada kolom userId dan blog_id dan akan dilakukan mapping terhadap dua kolom tersebut"""

# Mengubah userId menjadi list
user_id = blog_all['userId'].unique().tolist()
print('list userId: ', user_id)

# Encoding userId
user_to_user_encoded = {x: i for i, x in enumerate(user_id)}
print('encoded userId : ', user_to_user_encoded)

# Encoding angka ke userId
user_encoded_to_user = {i: x for i, x in enumerate(user_id)}

print('encoded angka ke userId: ', user_encoded_to_user)

# Mengubah blog_id menjadi list
blog_id = blog_all['blog_id'].unique().tolist()
print('list blog_id: ', blog_id)

# Encoding blog_id
blog_to_blog_encoded = {x: i for i, x in enumerate(blog_id)}
print('encoded blog_id : ', blog_to_blog_encoded)

# Encoding angka ke blog_id
blog_encoded_to_blog = {i: x for i, x in enumerate(blog_id)}

print('encoded angka ke blog_id: ', blog_encoded_to_blog)

"""---
# Modelling

Untuk sistem rekomendasi content based filtering akan digunakan cosine similarity dan euclidean distance untuk menentukan kemiripan antar item yang nantinya bisa direkomendasikan kepada user yang juga melihat item tersebut.

Untuk sistem rekomendasi collaborative filtering akan digunakan deep learning yang akan melakukan train data dan menampilkan rekomendasi untuk satu user.


---
"""

# Mapping userId ke dataframe user
blog_all['user'] = blog_all['userId'].map(user_to_user_encoded)

# Mapping blog_id ke dataframe blog
blog_all['blog'] = blog_all['blog_id'].map(blog_to_blog_encoded)

"""Melakukan cek jumlah user, blog, dan mengubah tipe data rating menjadi float"""

# Mendapatkan jumlah user
num_user = len(user_to_user_encoded)

# Mendapatkan jumlah blog
num_blog = len(blog_encoded_to_blog)

# Mengubah rating menjadi nilai float
blog_all['ratings'] = blog_all['ratings'].values.astype(np.float32)
blog_all['blog'] = blog_all['blog'].values.astype(np.int64)
blog_all['user'] = blog_all['user'].values.astype(np.int64)

# Nilai minimum rating
min_rating = min(blog_all['ratings'])

# Nilai maksimal rating
max_rating = max(blog_all['ratings'])

print('Jumlah User: {}, Jumlah Blog: {}, Min Rating: {}, Max Rating: {}, '.format(
    num_user, num_blog, min_rating, max_rating,
))

blog_all.info()

"""Selanjutnya dilakukan shuffle data agar distribusinya menjadi random"""

blog_all = blog_all.sample(frac=1, random_state=42)
blog_all

"""Melakukan inisialisasi untuk variabel x dan variabel y dan membagi data dengan proporsi 80%:20%"""

x = blog_all[['user', 'blog']].values
y = blog_all['ratings'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

train_indices = int(0.8 * blog_all.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)
print(x, y)

"""Membuat model deep learning untuk melakukan training data sistem rekomendasi collaborative filtering"""

class RecommenderNet(tf.keras.Model):

  # Insialisasi fungsi
  def __init__(self, num_user, num_blog, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_user = num_user
    self.num_blog = num_blog
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embeddings user
        num_user,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_user, 1) # layer embedding user bias

    self.blog_embedding = layers.Embedding( # layer embeddings blog
        num_blog,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.blog_bias = layers.Embedding(num_blog, 1) # layer embedding blog bias'

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:, 0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    blog_vector = self.blog_embedding(inputs[:, 1]) # memanggil layer embedding 3
    blog_bias = self.blog_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_blog = tf.tensordot(user_vector, blog_vector, 2)

    x = dot_user_blog  + user_bias + blog_bias

    return tf.nn.sigmoid(x) # activation sigmoid

# inisialisasi model RecommenderNet
model = RecommenderNet(num_user, num_blog, 100)

# Compile Model RecommenderNet
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.0001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model RecommenderNet menggunakan binary crossentropy untuk meminimalkan loss, Adam sebagai fungsi optimisasinya dan menggunakan mean absolute error (MAE) dan Root Mean Squared Error (RMSE) sebagai metrik evaluasinya."""

#Melakukan inisialisasi callbacks untuk model
callbacks = EarlyStopping(
    monitor ='val_root_mean_squared_error' ,
    mode='min',
    patience=1,
    restore_best_weights=True,
)

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 1024,
    epochs = 100,
    validation_data = (x_val, y_val),
    callbacks=[callbacks]
)

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

# inisialisasi model RecommenderNet
model_rms = RecommenderNet(num_user, num_blog, 100)

# Compile Model RecommenderNet
model_rms.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = tf.optimizers.RMSprop(1e-4),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

history_rms = model_rms.fit(
    x = x_train,
    y = y_train,
    batch_size = 1024,
    epochs = 100,
    validation_data = (x_val, y_val),
    callbacks=[callbacks]
)

plt.plot(history_rms.history['root_mean_squared_error'])
plt.plot(history_rms.history['val_root_mean_squared_error'])
plt.title('Model Metrics Optimizer RMSprop')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

fig, ax = plt.subplots(2, figsize=(16, 8))

mt1 = history.history['root_mean_squared_error']
mv1 = history.history['val_root_mean_squared_error']
mt2 = history_rms.history['root_mean_squared_error']
mv2 = history_rms.history['val_root_mean_squared_error']

ax[0].plot(mt1)
ax[0].plot(mv1)

ax[1].plot(mt2)
ax[1].plot(mv2)

for plot in ax.flat:
    plot.set(xlabel='rmse', ylabel='val-rmse')

plt.suptitle("Perbandingan Model dengan Optimizer Adam dengan RMSprop")

plt.show()

# Mengambil sample user
user_id = blog_all.userId.sample(1).iloc[0]
blog_read_by_user = blog_all[blog_all.userId == user_id]

# Operator bitwise
blog_not_read = blog_all[~blog_all['blog_id'].isin(blog_read_by_user.blog_id.values)]['blog_id']
blog_not_read = list(
    set(blog_not_read)
    .intersection(set(blog_to_blog_encoded.keys()))
)

blog_not_read = [[blog_to_blog_encoded.get(x)] for x in blog_not_read]
user_encoder = user_to_user_encoded.get(user_id)
user_blog_array = np.hstack(
    ([[user_encoder]] * len(blog_not_read), blog_not_read)
)

ratings = model.predict(user_blog_array).flatten()

# top rating
top_ratings_indices = ratings.argsort()[-10:][::-1]

# rekomendasi blog
recommended_blog_ids = [
    blog_encoded_to_blog.get(blog_not_read[x][0]) for x in top_ratings_indices
]

print('Menampilkan rekomendasi untuk user: {}'.format(user_id))
print('==' * 20)
print('blog dengan peringkat tinggi dari user')
print('--' * 20)

# mencari rekomendasi blog berdasarkan rating yang diberikan user
top_blog_user = (
    blog_read_by_user.sort_values(
        by = 'ratings',
        ascending=False
    )
    .head(5)
    .blog_id.values
)

df_blog_rows = blog_df[blog_df['blog_id'].isin(top_blog_user)]
for idx, row in enumerate(df_blog_rows.itertuples(index=False), start=1):
    print("{}. Title Blog:".format(idx), row[1])
    print("   Topic:", row[3])
    print()

print('--' * 20)
print('10 rekomendasi blog teratas')
print('--' * 20)

# rekomendasi blog
blog_top10 = blog_df[blog_df['blog_id'].isin(recommended_blog_ids)]

# fungsi perulangan untuk menampilkan rekomendasi blog dan topic sebanyak 10 buah
for idx, row in enumerate(blog_top10.itertuples(index=False), start=1):
    print("{}. Title Blog:".format(idx), row[1])
    print("   Topic:", row[3])
    print()

"""# Model Evaluation"""

model.save('saved_model/my_model')

